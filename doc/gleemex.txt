
Gleemex User Manual
===================
Philipp Kutin
:max-width: 56em
:numbered:
:toc:

:language: matlab

Introduction
------------

Gleemex is a high-level interface to OpenGL functionality for GNU Octave and
MATLAB^(R)^. It uses FreeGLUT to provide windowing and peripheral access for
various platforms, GLEW for OpenGL feature determination, and the MEX API to
communicate with the host program. It allows writing interactive graphical
applications entirely in the M scripting language.


Motivation
~~~~~~~~~~

The graphics systems of MATLAB and Octave are geared towards producing plots of
moderate complexity for offline display and printout, but are less suited for
writing applications that interact with the user. Gleemex enables the creation
of event-driven graphical tools, on one hand aiming at simplicity of usage, but
without sacrificing performance where it is needed. Its main virtues are in

* Being a _higher level_ interface to OpenGL. Thus, rather than exposing OpenGL
  functions directly, they are wrapped in commands that perform a composite
  function. At the same time, it tries to add as little overhead as possible.

* Providing _safety_ as a consequence of the above. It must not be possible to
  invoke erratic behavior (such as crashes caused by accessing memory out of
  some allowed bounds) by providing invalid data to Gleemex. Input is validated
  where necessary. If undefined behavior can be invoked from M code, it is
  always a Gleemex bug.

* Aiming at simplicity of both usage and concept. For example,

** After creating a window and adding the desired callbacks, starting the
   FreeGLUT main loop makes it run in a single thread of execution. This is in
   contrast to the native MATLAB ``handle graphics'' system, that allows for
   some form of concurrency.

** Drawing proceeds in a ``fire and forget'' fashion familiar from game
   programming. Instead of having to _manage_ objects (such as lines) by
   writing separate code for their creation, potential update, and deletion, a
   customary Gleemex app only keeps some _state_ in a global M variable. In the
   display callback, that state is then used to render one frame.

* Being strict with regard to errors. Any error from M code while the main loop
  is active makes Gleemex close all of its windows and report it. This eases
  debugging of graphical apps, since otherwise an erroneous condition may
  produce followup failures, obscuring the original cause.

Installation
~~~~~~~~~~~~

:FreeGLUT: http://freeglut.sourceforge.net/
:GLEW: http://glew.sourceforge.net/

The Gleemex core is implemented in a single source file, `glcall.c`. On a
supported combination of OS, architecture and M-language implementation, and
assuming a compatible C compiler is installed (see ``++help mex++''), running
`mkglcall` usually suffices to build a dynamically loaded MEX library that can
be used with the given setup.

Gleemex depends on {FreeGLUT}[FreeGLUT] and {GLEW}[GLEW]. For convenience, on
Windows, GLEW is packaged together with Gleemex and does not need to be
installed separately.

//////////
Usage overview
~~~~~~~~~~~~~~

From a bird's eye perspective, a Gleemex application maintains app-related
state, handles events such as key presses, and redraws the view when
necessary. It is customary to keep the state in a *`global`* struct
variable,footnote:[It may be preferable to use a custom object of a
_handle_-derived class, but as of time of writing, classdef functionality is
not present in Octave mainline yet.] one per application. If it is desired that
an app may have multiple windows, additional measures have to be taken.

// TODO: write about those measures.
//////////


The `glcall` API
----------------

The `glcall` MEX function is the only entry point to Gleemex. It consolidates
various sub-functions which are selected depending on the first argument passed
to it, the _command_. Invoking `glcall` without input arguments returns a
struct containing a mapping of names to numeric constants denoting these
commands, as well as those of callback functions to be registered once a window
has been created.
This struct should be stored in a global named `glc`.

//It is customary, but not required, to store this struct in a
//global named `glc`.

Another function, `glconstants`, returns a struct containing mappings for
OpenGL and FreeGLUT constants, together with some auxiliary definitions. By
convention, it is stored into a global `GL`.footnote:[Conceptually, one does
not _need_ to use the names ```glc`'' and ```GL`''. However, currently Gleemex
references these named globals in M-file auxiliary functions ``behind a user's
back'' without first assigning to them. In the future, the restriction to use
these particular names may be lifted by substituting the numerical values for
these references.]

Thus, in the ``main'' function of an application, one usually initializes these
two globals for future use as follows:

[source]
.`hello_gleemex.m`
----------
function hello_gleemex()
    global GL glc
    glc = glcall();
    GL = glconstants();

    % ...
end
----------


Callback functions
~~~~~~~~~~~~~~~~~~

Callback functions are user-defined functions that are invoked when a
particular event, such as a mouse press, happens. Because the MEX API provides
no means of inspecting _function handle_ objects, callbacks are passed to
Gleemex *by name*. For example, the preceding hello-world app could register a
display callback named `hg_display` like this:

[source]
----------
function hello_gleemex()
    % ...

    glcall(glc.setcallback, glc.cb_display, 'hg_display');
    % ...
end

function hg_display()
    global GL glc
    glcall(glc.clear, [1 0 0]);  % clear the window to a red color
end
----------

How the actual function corrensponding to a particular name is looked up
differs between Octave and MATLAB. In Octave, it is possible to call secondary
functions by name when the primary function is active, but only when the latter
(here, `hello_gleemex`) has been invoked from the top level!

In MATLAB, secondary functions appear to never be considered. For this reason,
they can either be written in separate files from the start, or have to be
extracted from the common file. A helper function `extractsecfuncs` is provided
for this task.


Initialization, setup and teardown commands
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:FGAPI: http://freeglut.sourceforge.net/docs/api.php

[float]
==== `WINID = glcall(glc.newwindow, POS, EXTENT, WINDOWNAME [, OPTS])`

:glutCreateSubWindow: http://www.opengl.org/documentation/specs/glut/spec3/node17.html#SECTION00052000000000000000

Creates a new (sub-)window with the given properties and a separate, new OpenGL
context. To make the window do something useful, it needs to have callbacks
attached afterwards.

* `WINDOWNAME`: the name of the window, to be shown in the top bar

* `POS`: the initial (x, y) position of the window, must be of type `double`
* `EXTENT`: the initial (width, height) pair of the window, must be of type
  `double`
+
When creating a top-level window (`OPTS.subwindow` not given or false), `POS`
and `EXTENT` are passed to {FGAPI}[`glutInitWindowPosition`] and
{FGAPI}[`glutInitWindowSize`], respectively. Otherwise, they are passed to
{glutCreateSubWindow}[`glutCreateSubWindow`].

* `OPTS`: A struct containing additional options:

** `multisample`: Pass `GLUT_MULTISAMPLE` to {FGAPI}[`glutInitDisplayMode`]?
** `subwindow`: If true, creates a sub-window in the current window instead of
   a new top-level one.

** `menus`: A special kind of struct (called _menu struct_ from now on) that
   defines a menu to be opened when a particular mouse button is pressed in the
   window to be created. The menu has some top-level properties and may
   recursively include sub-menus. Consequently, some of its fields may only
   appear in the outermost struct, while others are also allowed to exist in
   those nested deeper.
*** `button` (top level only): the button that needs to be pressed in order to
    open the menu
*** `cbfunc`: The name of the callback function to be invoked when the user
    activates a menu entry. It may appear in both root and child menu structs,
    with semantics detailed below.
*** `entries`: A cell array +{ e~1~, e~2~, ..., e~n~ }+ sequence of the menu's
    entries, in the order they ultimately appear. An element +e~i~+ can be
    either a leaf that can be activated, or another sub-menu. Where this cell's
    element is a string, the entry is considered a leaf, and the string is
    taken as its label in the menu. Otherwise, the element is expected to be a
    menu struct describing the child, and its label is taken from the child's
    `label` field.
*** +label+: (child only): the label of the sub-menu which this menu
    struct describes in its parent's menu

** When the user activates a menu entry, a suitable callback function is
   searched first. Conceptually, this is done by traversing the menu tree,
   starting at the selected entry and working towards the root (i.e. following
   the ``parent'' links). When a menu struct containing a `cbfunc` field is
   encountered, the named function is invoked with two arguments:
   `cbfunc(label, idx)`.

*** `label`: the label of the menu entry, as given in the menu struct
*** `idx`: TODO (not yet specified)

The return value `WINID` is a small integer identifying the window for as long
as it is live. Note that it's *not* the identifier passed from FreeGLUT but one
specific to Gleemex. Its values are in the range
[1{nbsp}..{nbsp}`MAXACTIVEWINDOWS`], where at most `MAXACTIVEWINDOWS` can be
open at the same time (currently, 32). The identifiers of windows that have
been closed may subsequently be reused.

[float]
[[glc_closewindow]]
==== `glcall(glc.closewindow [, WINID])`

Closes the window given by the Gleemex identifier `WINID`, or the current
window if `WINID` is omitted.

[float]
==== `glcall(glc.setcallback, CALLBACK_KIND, CBFUNC_NAME)`

:FGWindowCallback: http://freeglut.sourceforge.net/docs/api.php#WindowCallback

Sets the specified callback `CALLBACK_KIND` of the current window to the
function named `CBFUNC_NAME`. The following values are permissible for
`CALLBACK_KIND`; the names in angle brackets denote the respective GLUT
registration functions.

`glc.cb_display`, [`glutDisplayFunc`]::

Invoked with no arguments when the windows is about to be redrawn. At the end,
Gleemex always issues a `glutSwapBuffers()`.

`glc.cb_reshape`, [`glutReshapeFunc`]::

Invoked with two arguments `(width, height)` when the window has been resized,
and on initialization. Thus, it is possible to e.g. set up a projection matrix
in this callback. If no custom reshape callback is registered, Gleemex
registers one that issues `glViewport(0, 0, width, height)`.

`glc.cb_position`, [{FGWindowCallback}[`glutPositionFunc`]]::

Invoked with two arguments `(x, y)` when the window is repositioned/moved
programatically or by the user.

`glc.cb_keyboard`, [`glutKeyboardFunc`, `glutSpecialFunc`]::

Invoked with four arguments `(key, x, y, mods)` when a keyboard key has been
pressed. Gleemex consolidates the two GLUT callback functions into one for ease
of use. The `key` argument can be checked for equality with either a
single-character string such as `'a'`, or with constants `GL.KEY_*`. The
`mods` argument denotes which modifier keys are pressed and can be checked
against the `GL.MOD_*` bit constants.
+
NOTE: For ``key chords'' such as `Ctrl`+`a`, FreeGLUT may pass different
combinations of `key` and `mods` on different platforms.

`glc.cb_mouse`, [`glutMouseFunc`]::

Invoked with five arguments `(button, downp, x, y, mods)` when a mouse button
is pressed (`downp` is true) or released (`downp` is false). The `button`
arguments can be checked against the `GL.BUTTON_*` and `GL.MWHEEL_*` bit
constants, `mods` are the pressed modifier keys as with the keyboard callback.

`glc.cb_motion`, [`glutMotionFunc`, `glutPassiveMotionFunc`]::

Invoked with three arguments `(buttons, x, y)` when the mouse is moved. The
`buttons` argument has the `GL.BUTTON_*` bits set which are depressed at the
time the movement happens.
+
NOTE: Currently, `buttons` may not be entirely reliable in multi-window
scenarios.

[float]
==== `glcall(glc.entermainloop)`

Enters the FreeGLUT main loop once. Issuing `glc.entermainloop` while the main
loop is active is a no-op.

[float]
==== `glcall(glc.leavemainloop)`

Instructs FreeGLUT to stop executing the main loop. This will close *all*
Gleemex windows and return to the prompt of the M-language implementation.
In most cases, <<glc_closewindow,`glc.closewindow`>> should be preferred.

[float]
==== `[STR1, STR2, EX] = glcall(glc.geterrstr)` {nbsp} [MATLAB only]

Returns information about the last error.

Currently, on Octave, when an error happens, Gleemex immediately issues
`mexErrMsgText` and thus effectively does non-local control flow back to the
prompt. *TODO*: it is not clear by itself that this is correct, i.e. doesn't
leak resources (or worse).

On MATLAB, issuing `mexErrMsgText` while the FreeGLUT main loop is active has
been found to produce crashes, which is why a different approach is taken: the
error message is backed up in persistent variables, and control is returned to
the prompt by normally returning from all active Gleemex functions and
terminating the FreeGLUT main loop.

The `glc.geterrstr` command can be used to query the messages of the last error
(`STR1` and `STR2`) as well as obtain the `MException` associated with it,
`EX`, from the MATLAB prompt. Thus, after your Gleemex app terminates
abnormally, you'd usually issue

[source]
----------
global glc
[a,b,c] = glcall(glc.geterrstr);
c.getReport()
----------

to pretty-print the error together with a backtrace.


Commands that change or query OpenGL state
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[float]
[[glc_viewport]]
==== `glcall(glc.viewport, XYWH)`

:glViewport: http://www.opengl.org/sdk/docs/man2/xhtml/glViewport.xml

Sets the viewport by calling {glViewport}[`glViewport`] with the elements of
`XYWH`, which must be a 4-vector of type `double`.

[float]
==== `glcall(glc.scissor, XYWH)`

:glScissor: http://www.opengl.org/sdk/docs/man2/xhtml/glScissor.xml

Defines a scissor box by calling {glScissor}[`glScissor`] with the elements of
`XYWH`, which must be a 4-vector of type `int32`.

[float]
==== `glcall(glc.toggle, KV_PAIRS)`

:glEnable: http://www.opengl.org/sdk/docs/man2/xhtml/glEnable.xml

Toggles the {glEnable}[enable] state of various server-side GL capabilities.

* `KV_PAIRS`: A vector of even length containing successive pairs of `KEY` and
  `VALUE`. Must be of type `int32`; this is automatically ensured if `KV_PAIRS`
  is constructed as concantenation of values containing `GL.*` values, as
  detailed below.

** `KEY`: An allowed GL constant denoting the capability: one of
   `GL.DEPTH_TEST`, `GL.SCISSOR_TEST`, `GL.BLEND`, `GL.POINT_SMOOTH`,
   `GL.LINE_SMOOTH`, `GL.LINE_STIPPLE`, `GL.POLYGON_SMOOTH` or `GL.FOG`.

** `VALUE`: 1 for enabling the capability, 0 for disabling it, or -1 for
   flipping its enable state.

.Example
[source]
----------
    % enable depth testing and blending
    glcall(glc.toggle, [GL.DEPTH_TEST 1, GL.BLEND 1]);
----------

[float]
==== `glcall(glc.push, WHAT)` and `glcall(glc.pop, WHAT)`

:glPushMatrix: http://www.opengl.org/sdk/docs/man2/xhtml/glPushMatrix.xml
:glPushAttrib: http://www.opengl.org/sdk/docs/man2/xhtml/glPushAttrib.xml

Pushes or pops the {glPushMatrix}[matrix] or {glPushAttrib}[server attribute]
stack. `WHAT` is a vector of constants denoting what to push or pop: allowed
values are

* `GL.PROJECTION`, `GL.MODELVIEW` and `GL.TEXTURE` for the respective matrices
* The `GL.*_BIT` constants for the sets of attributes documented in
  {glPushAttrib}[`glPushAttrib`]

[float]
==== `glcall(glc.set, WHAT, VALUE)`

:glPointSize: http://www.opengl.org/sdk/docs/man2/xhtml/glPointSize.xml
:glLineWidth: http://www.opengl.org/sdk/docs/man2/xhtml/glLineWidth.xml
:glLineStipple: http://www.opengl.org/sdk/docs/man2/xhtml/glLineStipple.xml

:glBlendEquation: http://www.opengl.org/sdk/docs/man2/xhtml/glBlendEquation.xml
:glDepthFunc: http://www.opengl.org/sdk/docs/man2/xhtml/glDepthFunc.xml
:glDepthMask: http://www.opengl.org/sdk/docs/man2/xhtml/glDepthMask.xml

Sets the GL and FreeGLUT state variable denoted by `WHAT` to a new
value. `WHAT` can be one of the following named Gleemex constants:

* `GL.MENU_ENABLE`: `VALUE` is a scalar logical of whether to enable
  the menu in the current window.

* `GL.MOUSE_POS`: `VALUE` is a 2-vector of type `double` whose
  elements are passed to `glutWarpPointer`. The values must be greater or equal
  0 and less that or equal to the width/height of the window.

* `GL.WINDOW_ID`: TODO
* `GL.WINDOW_SIZE`: TODO

* `GL.POINT_SIZE`: `VALUE` is a `double`-typed scalar passed to
  {glPointSize}[`glPointSize`].

* `GL.LINE_WIDTH`: `VALUE` is a `double`-typed scalar passed to
  {glLineWidth}[`glLineWidth`].

* `GL.LINE_STIPPLE_PATTERN`: `VALUE` is a `uint16`-typed scalar passed as the
  _pattern_ to {glLineStipple}[`glLineStipple`]. For the _factor_ argument, 1
  is passed.

* `GL.BLEND_EQUATION`: `VALUE` is a GL constant permissible to
  {glBlendEquation}[`glBlendEquation`]: `GL.MIN`, `GL.MAX`, `GL.FUNC_ADD`,
  `GL.FUNC_SUBTRACT` or `GL.FUNC_REVERSE_SUBTRACT`.

* `GL.DEPTH_FUNC`: `VALUE` is a GL constant permissible to
  {glDepthFunc}[`glDepthFunc`]: `GL.NEVER`, `GL.LESS`, `GL.EQUAL`,
  `GL.LEQUAL`, `GL.GREATER`, `GL.NOTEQUAL`, `GL.GEQUAL` or `GL.ALWAYS`.

* `GL.DEPTH_WRITEMASK`: `VALUE` is a scalar logical, whose corresponding GL
  value (`GL.TRUE` or `GL.FALSE`) is passed to {glDepthMask}[`glDepthMask`].

[float]
==== `VALUE = glcall(glc.get, WHAT)`

Gets the current value of the GL or FreeGLUT state variable denoted by `WHAT`.

* `GL.WINDOW_ID`: see `glc.set`
* `GL.WINDOW_SIZE`: see `glc.set`
* `GL.WINDOW_POS`: TODO

* `GL.PROJECTION_MATRIX`, `GL.MODELVIEW_MATRIX`: `VALUE` is a 4-by-4
  `double`-typed matrix.


[float]
[[glc_setmatrix]]
==== `glcall(glc.setmatrix, WHICH, M)`

:glLoadMatrix: http://www.opengl.org/sdk/docs/man2/xhtml/glLoadMatrix.xml
:glOrtho: http://www.opengl.org/sdk/docs/man2/xhtml/glOrtho.xml
:gluPerspective: http://www.opengl.org/sdk/docs/man2/xhtml/gluPerspective.xml

Sets the `GL.PROJECTION` or `GL.MODELVIEW` matrix (given by `WHICH`) to `M`,
which must be a `double`-typed matrix and can be one of the following:

* An empty array `[]` is interpreted to reset the respective matrix to the
  identity matrix.
* A 4-by-4 matrix is passed unmodified to {glLoadMatrix}[`glLoadMatrixd`].
* For `GL.PROJECTION`, it is possible to pass a vector of length 4 or 6.
** The elements of a 4-vector are passed to {gluPerspective}[`gluPerspective`].
** The elements of a 6-vector are passed to {glOrtho}[`glOrtho`].

[float]
==== `glcall(glc.fog, FOG_MODE, FOG_PARAM, FOG_COLOR)`

:glFog: http://www.opengl.org/sdk/docs/man2/xhtml/glFog.xml

Sets the {glFog}[fog] parameters and color.

* `FOG_MODE`: one of `GL.LINEAR`, `GL.EXP` or `GL.EXP2`
* `FOG_PARAM`: for `GL.LINEAR` fog, a 2-vector specifying the near and far
  distances for the linear fog equation. Otherwise, the fog density. Must have
  numeric type `single`.
* `FOG_COLOR`: a 4-vector of `single` numeric type specifying the color of the
  fog


Drawing and related commands
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[float]
==== `glcall(glc.clear [, COLOR])`

:glClear: http://www.opengl.org/sdk/docs/man2/xhtml/glClear.xml

{glClear}[Clears] the depth buffer to 1. Also, if `COLOR` is provided as an
`(R, G, B [, A])` vector of type `double`, the color buffer is cleared to that
value.

[float]
==== `glcall(glc.draw, PRIMITIVE_TYPE, VERTEXDATA [, OPTSTRUCT])`

:glDrawElements: http://www.opengl.org/sdk/docs/man2/xhtml/glDrawElements.xml
:glBegin: http://www.opengl.org/sdk/docs/man2/xhtml/glBegin.xml

Passes vertex data to OpenGL, instructing it to draw them as primitives of
`PRIMITIVE_TYPE` and optionally providing face indices, colors and/or texture
coordinates.

* `PRIMITIVE_TYPE`: The kind of geometric {glBegin}[primitive] to draw, one of +
  `GL.POINTS`, `GL.LINES`, `GL.LINE_LOOP`, `GL.LINE_STRIP`, `GL.TRIANGLES`,
  `GL.TRIANGLE_STRIP`, `GL.TRIANGLE_FAN`, `GL.QUADS`, `GL.QUAD_STRIP` or
  `GL.POLYGON`. +
  If 16 is added to `PRIMITIVE_TYPE`, only the outlines of polygons are drawn.

* `VERTEXDATA`: A `(K, NumTotalVerts)` matrix of floating numeric type
  containing the vertex coordinates of the primitives.

** `K`: The number of ``dimensions''. Can be 2, 3 or 4, corresponding to x, y,
  z and/or w coordinates.
** `NumTotalVerts`: The total number of vertices, must be consistent with the
  given `PRIMITIVE_TYPE`. For example, requesting `GL.LINES` expects
  `NumTotalVerts` to be even.

* `OPTSTRUCT`: A struct that can be used to pass additional data. May contain
  the following fields:

** `colors`: The `(R, G, B [, A])` colors. Can be either a vector of length 3 or 4,
   in which case all vertices are given that color, or a `(3 or 4,
   NumTotalVerts)` matrix, specifying a separate color for each vertex. Must
   have type `double`. +
   If no colors are passed, the default one is white when a texture is
   provided, and (0.5, 0.5, 0.5) otherwise.

** `indices`: Zero-based indices into the columns of `VERTEXDATA` used to
   construct the primitives. See {glDrawElements}[`glDrawElements`]. Must have
   _index type_ (`uint8` or `uint32`). +
   When `indices` are passed, the number of drawn vertices is thus its length,
   and each of its elements must be less than `NumTotalVerts`. This bound check
   has to be done every `glc.draw` call, so providing a large amount of indices
   may be expensive.

** `tex`: The OpenGL _texture name_ (a non-zero `uint32` number as returned by
   <<glc_newtexture,`glc.newtexture`>>) with which the primitives are to be
   textured.

** `texcoords`: The s and t texture coordinates at each vertex. Must be a `(2,
   NumTotalVerts)` matrix of floating numeric type. Must be passed whenever
   `tex` is passed.

[float]
==== `glcall(glc.text, POS, HEIGHT, TEXT [, XYALIGN] [, OPTS])`

Renders a line of text using a FreeGLUT's roman stroke font.

Assuming that <<glc_setup2d,`glc_setup2d`>> has been used to set up a 2D view,
the string `TEXT` is drawn at pixel position `POS` and height `HEIGHT` (which
should be a `double`-typed 2-vector and scalar, respectively). `TEXT` should
not contain newlines.

* `XYALIGN`: an optional `double`-typed 2-vector `[xalign yalign]` specifying
  the horizontal and vertical alignment of the text.

** --1: align on left/bottom (i.e. towards negative coordinates)
** 0: align at the center
** 1: align on right/top

* `OPTS`: an option struct which may contain the following fields:

** `colors`: a 3-vector of type `double` giving the `(R, G, B)` color of the
   text

** `xgap`: The distance between successive characters, expressed as a
   proportion of the width of the space character. The default is a value that
   was experimentally determined to look good. Must have `double` type.

** `mono`: a scalar logical of whether to use the monospaced Roman font

[float]
==== `glcall(glc.redisplay [, NOW])`

:glutPostRedisplay: http://www.opengl.org/documentation/specs/glut/spec3/node20.html#SECTION00055000000000000000
:glutSwapBuffers: http://www.opengl.org/documentation/specs/glut/spec3/node21.html#SECTION00056000000000000000

With no additional arguments, issues {glutPostRedisplay}[`glutPostRedisplay`].
If `NOW` is passed, it should be a scalar logical; if `NOW` is true,
{glutSwapBuffers}[`glutSwapBuffers`] is issued instead.

[float]
==== `PIXELS = glcall(glc.readpixels [, XYWH])`

:glReadPixels: http://www.opengl.org/sdk/docs/man2/xhtml/glReadPixels.xml

{glReadPixels}[Reads] a block of pixels from the framebuffer. If `XYWH` is
passed (which must be a `double`-typed 4-vector), its elements are passed to
the _x_, _y_, _width_ and _height_ arguments of `glReadPixels`. Otherwise, the
default is to grab the whole window.

`PIXELS` is returned as a 3-by-_width_-by-_height_ `uint8` array.


Resource definition commands
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[float]
[[glc_texture]]
==== `TEXID = glcall(glc.texture, TEXIMG [, OPTS])` or `glcall(glc.texture, TEXIMG, TEXID [, OPTS])`

:glTexImage2D: http://www.opengl.org/sdk/docs/man2/xhtml/glTexImage2D.xml

{glTexImage2D}[Uploads] an image `TEXIMG` for a texture, either creating a new
GL texture name `TEXID` (first form) or reusing an already given texture name
(second form). Various options in `OPTS` allow either modifying certain aspects
of the texture rendering such as its filtering, or control how `TEXIMG` itself
is interpreted.

The format and type of a color component of the texture is determined by
various properties of `TEXIMG`:

* `TEXIMG` can be a `width`-by-`height` matrix. In this case, it is uploaded
  using the `GL_LUMINANCE` format. As a special case, if `OPTS.u32rgba` is
  given and true, `TEXIMG` must have class `uint32` and the 32-bit unsigned
  integers are interpreted as RGBA quadruplets (least significant byte is red).

* `TEXIMG` can be a `k`-by-`width`-by-`height` array, with `k` being the number
   of color components in the texture. It can be one of 2, 3 or 4, in which
   case the texture is uploaded in `GL_LUMINANCE_ALPHA`, `GL_RGB` or `GL_RGBA`
   format, respectively.

* `TEXIMG` may have either `single` numeric class, or one of `[u]int{8,16,32}`.

`OPTS` may be a struct containing the following fields:

* `u32rgba`: described above

* `minmag`: a scalar or 2-vector containing the GL constants denoting the
  minification and magnification filters. Each one can be `GL.NEAREST` or
  `GL.LINEAR`. If a scalar is passed, both filters are set to the given
  mode. The default is `GL.LINEAR`.

Currently, there is no way to set the texture's wrapping mode: it is always set
to `GL_CLAMP_TO_EDGE`. Uploading mipmaps is not supported, either.

[float]
==== `glcall(glc.deletetextures, TEXIDS)`

:glDeleteTextures: http://www.opengl.org/sdk/docs/man2/xhtml/glDeleteTextures.xml

{glDeleteTextures}[Deletes] the textures named by the elements of the vector
`TEXIDS`.

[float]
[[glc_colormap]]
==== `glcall(glc.colormap, COLORMAP)`

Uploads a colormap texture and binds it as a one-dimensional texture to a
texture unit different from `GL_TEXTURE0`. The texture is set to linear
filtering and `GL_CLAMP_TO_EDGE` wrapping.

* `COLORMAP`: must be a 3-by-256 `uint8` matrix of (R, B, G) colors.

This command allows using the so registered colormap from fragment shaders. See
the notes labeled [red]#COLORMAP_DEF# below.


Fragment shader commands
~~~~~~~~~~~~~~~~~~~~~~~~

[float]
[[glc_newfragprog]]
==== `PROGID [, UNIFORMS] = glcall(glc.newfragprog, FRAGSHADERSRC)`

:glCompileShader: http://www.opengl.org/sdk/docs/man2/xhtml/glCompileShader.xml
:glAttachShader: http://www.opengl.org/sdk/docs/man2/xhtml/glAttachShader.xml
:glLinkProgram: http://www.opengl.org/sdk/docs/man2/xhtml/glLinkProgram.xml

:glGetActiveUniform: http://www.opengl.org/sdk/docs/man2/xhtml/glGetActiveUniform.xml

{glCompileShader}[Compiles] a single fragment shader given in the source
`FRAGSHADERSRC` and {glLinkProgram}[links] a fragment program containing it as
the only {glAttachShader}[attached] shader. If either the creation of a shader
or program object failed, or there was an error with compilation or linking, an
M error is issued.

[red]#COLORMAP_DEF#: If the fragment shader contains a uniform variable named
`cmap`, it must be declared with `uniform sampler1D` type. In the shader, you
can sample the colormap texture, for example

[source,glsl]
----------
uniform sampler1D cmap;
int main(void) {
  // ...
  float val = /* (some value in [0 .. 1] */;
  vec3 rgb = texture1D(cmap, val).rgb;  // get the RGB triplet for 'val'
  // ...
}
----------

On success, returns

* `PROGID`: an identifier by which the created fragment program can be
  referenced. The fragment program is *not* enabled by creating it, use
  <<glc_fragprog,`glc.usefragprog`>> for this.

* `UNIFORMS`: optionally, a mapping of {glGetActiveUniform}[active uniform]
  variable names that are also valid MATLAB identifiers to Gleemex-specific
  handles permissible to <<glc_setuniform,`glc.setuniform`>>. Only names of
  user-defined uniform variables with the following types are listed (the
  variables may be either scalars or arrays of these _base types_):

** base scalars: `GL_BOOL`, `GL_FLOAT`, `GL_INT`
** base vectors: `GL_{BOOL,INT,FLOAT}_VEC{2,3,4}`

[float]
[[glc_fragprog]]
==== `glcall(glc.usefragprog [, PROGID])`

:glUseProgram: http://www.opengl.org/sdk/docs/man2/xhtml/glUseProgram.xml
{glUseProgram}[Enables] usage of the fragment program `PROGID` (if passed) or
disables any fragment program and revert to OpenGL fixed functionality (if
`PROGID` is omitted).

[red]#COLORMAP_DEF#: If the fragment shader containes a `cmap` uniform
variable, it it set to the texture unit to which the texture uploaded with
<<glc_colormap,`glc.colormap`>> binds.

[float]
[[glc_setuniform]]
==== `glcall(glc.setuniform, UNIFORMHANDLE, VAL)`

:glUniform: http://www.opengl.org/sdk/docs/man2/xhtml/glUniform.xml

{glUniform}[Sets] the value of a uniform variable in the currently active
fragment program.

* `UNIFORMHANDLE`: The Gleemex handle denoting a uniform variable as returned
  as one of the keys of the `UNIFORMS` mapping from
  <<glc_newfragprog,`glc.newfragprog`>>.

* `VAL`: A value consistent with the type and size of the corresponding uniform
  variable.

** For `GL_FLOAT`-typed uniforms, values of M type `single` are expected. For
  uniforms of type `GL_BOOL` or `GL_INT`, values of M type `int32` should be
  passed.

** For scalar uniforms, `VAL` should contain as many elements as suggested by
   the _base type_: a single element for `GL_{BOOL,FLOAT,INT}` and 2, 3 or 4
   for `GL_*_VEC{2,3,4}` (respectively).

** For array uniforms, `VAL` should have length equal to the length of the
   array, times the base element count as described with the previous point.

// XXX: ^^ ^^ 'scalar' may be confusing since it's used in a different sense than
// 'base scalar' above.

// TODO: ^^ actually, the implementation for array uniforms is less strict (can
// set prefix of array, I think). Use case?


Auxiliary functions
-------------------

Gleemex provides a number of convenience functions built on top of the basic
`glcall` routines.

[float]
[[glc_setup2d]]
==== `glc_setup2d(WIDTH, HEIGHT [, ZRANGE])`

Sets up the viewport and projection matrix suitable for 2D drawing in a window
of size `WIDTH` and `HEIGHT`, and resets the modelview matrix to the identity
matrix.  In the so constructed view, position (1, 1) denotes the center of the
leftmost and bottommost pixel. +

NOTE: `glc_setup2d` achieves the above-mentioned convention by calling
<<glc_setmatrix,`glc.setmatrix`>>/`GL.PROJECTION` with a 6-vector, where the
first four values are 0, `WIDTH`, 0 and `HEIGHT`, to all of which 0.5 is added.
The last two values are those given by `ZRANGE`, or `[-1 1]` by default.

[float]
==== `glc_axes_setup(VIEWPORT_XYWH, PROJECTION [, ADDITIONAL_BITS])` -> `true`

Sets up an ``axes'' as a rectangular region of the current window given by
`VIEWPORT_XYWH`, which should be a 4-vector permissible to
<<glc_viewport,`glc.viewport`>>. Drawing commands between a call to
`glc_axes_setup` and a closing `glc_axes_finish` will never draw outside this
region. The `PROJECTION` argument can be anything permissible to
<<glc_setmatrix,`glc.setmatrix`>>; the modelview matrix is reset to the
identity matrix.

Always returns `true`.

NOTE: `glc_axes_setup` pushes the following matrices and server-side attribute
bits: `GL.PROJECTION`, `GL.MODELVIEW`,
`GL.VIEWPORT_BIT+GL.SCISSOR_BIT+GL.ENABLE_BIT`. Additional attribute bits may
be pushed by passing `ADDITIONAL_BITS`.

[float]
==== `glc_axes_finish()`

// TODO: document BORDERCOLOR?
Restores the matrices and server attributes pushed by `glc_axes_setup`.

